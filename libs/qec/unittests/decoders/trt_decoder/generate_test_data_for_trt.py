import stim
import torch
import torch.nn as nn

# --------------------------
# Load the trained model
# --------------------------
# Parameters must match training script
distance = 3
num_rounds = 3
hidden_dim = 128
error_prob = 0.001

# Build the same circuit
circuit = stim.Circuit.generated(
    "surface_code:rotated_memory_x",
    distance=distance,
    rounds=num_rounds,
    after_clifford_depolarization=error_prob,
    after_reset_flip_probability=error_prob,
    before_measure_flip_probability=error_prob,
    before_round_data_depolarization=error_prob
)

dem = circuit.detector_error_model()
num_detectors = dem.num_detectors

# Generate test data
num_test_samples = 200
sampler = circuit.compile_detector_sampler()

print(f"Generating {num_test_samples} test samples...")
detector_samples, observable_samples = sampler.sample(num_test_samples, separate_observables=True)

X_test_data = []
Y_test_data = []

for i in range(num_test_samples):
    detectors = torch.tensor(detector_samples[i], dtype=torch.float32)
    observable = torch.tensor(observable_samples[i], dtype=torch.float32)
    X_test_data.append(detectors)
    Y_test_data.append(observable)

X_test = torch.stack(X_test_data)
Y_test = torch.stack(Y_test_data)

num_observables = Y_test.shape[1]

# Reconstruct model architecture
class SurfaceCodeDecoder(nn.Module):
    def __init__(self, input_dim, output_dim, hidden_dim=128, dropout=0.3):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(input_dim, hidden_dim * 2),  # 256
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden_dim * 2, hidden_dim),  # 128
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden_dim, hidden_dim // 2),  # 64
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden_dim // 2, output_dim),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.net(x)

# Load the trained model
model = SurfaceCodeDecoder(input_dim=num_detectors, output_dim=num_observables, 
                           hidden_dim=hidden_dim, dropout=0.3)
model.load_state_dict(torch.load("surface_code_decoder_best.pth"))
model.eval()

# Get predictions
print("Running inference on test samples...")
with torch.no_grad():
    predictions = model(X_test)

# Generate C++ header file
print("Generating C++ header file...")
with open("trt_test_data.h", "w") as f:
    f.write("// Auto-generated test data for TRT decoder\n")
    f.write("// Generated by generate_test_data_for_trt.py\n")
    f.write("\n")
    f.write("#pragma once\n")
    f.write("\n")
    f.write("#include <vector>\n")
    f.write("\n")
    f.write(f"constexpr int NUM_TEST_SAMPLES = {num_test_samples};\n")
    f.write(f"constexpr int NUM_DETECTORS = {num_detectors};\n")
    f.write(f"constexpr int NUM_OBSERVABLES = {num_observables};\n")
    f.write("\n")
    f.write("// First 100 test cases\n")
    f.write("const std::vector<std::vector<float>> TEST_INPUTS = {\n")
    
    for i in range(min(100, num_test_samples)):
        input_data = X_test[i].numpy()
        f.write("    {")
        f.write(", ".join([f"{x:.1f}" for x in input_data]))
        f.write("}")
        if i < min(100, num_test_samples) - 1:
            f.write(",")
        f.write("\n")
    
    f.write("};\n")
    f.write("\n")
    f.write("const std::vector<std::vector<float>> TEST_OUTPUTS = {\n")
    
    for i in range(min(100, num_test_samples)):
        output_data = predictions[i].numpy()
        f.write("    {")
        f.write(", ".join([f"{x:.6f}" for x in output_data]))
        f.write("}")
        if i < min(100, num_test_samples) - 1:
            f.write(",")
        f.write("\n")
    
    f.write("};\n")

print(f"Test data header file generated: trt_test_data.h")
print(f"  - Number of test samples: {min(100, num_test_samples)}")
print(f"  - Number of detectors: {num_detectors}")
print(f"  - Number of observables: {num_observables}")
